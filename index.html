<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale-1.0"/>
<title>Echoes of a Forgotten System | The Architect's Will</title>
<style>
  html, body {
    margin:0; padding:0; background:#0a0a0a; color:#eee; font-family: "Courier New", monospace;
    height:100%;
  }
  #wrap {
    display:flex; align-items:center; justify-content:center; height:100%;
  }
  canvas { 
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background:#000;
    border:4px solid #fff;
  }
  #hint {
    position: fixed; left: 0; right: 0; bottom: 0;
    padding:10px 14px; font-size:14px; color:#bbb; background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.65));
    text-align:center; pointer-events:none;
  }
</style>
</head>
<body>
<div id="wrap"><canvas id="game" width="640" height="360"></canvas></div>
<div id="hint">이동: 화살표 | 상호작용/확인: Z/Enter | 취소: X | 전투 메뉴: ←→ | 서브메뉴: ↑↓</div>

<script>
/* ===================================================================
   ECHOES OF A FORGOTTEN SYSTEM (v3.5 - BGM Update)
   - 보스별 BGM(배경 음악) 시스템 추가 (Track1.mp3 ~ Track5.mp3)
   - BGM 비동기 로딩, 루프 재생, 에러 핸들링 기능 구현
   - 모든 이전 버전의 버그 수정 사항 포함
   =================================================================== */

const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');

// ------------------------------------------------------------
// 공용 유틸
// ------------------------------------------------------------
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a, b) => Math.random() * (b - a) + a;
const randi = (a, b) => Math.floor(rand(a, b));
const now = () => performance.now();
const shuffle = (a) => { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; };

function drawRect(x,y,w,h,color="#fff",fill=true, lw=1) { ctx.save(); ctx.lineWidth = lw; ctx.strokeStyle = color; ctx.fillStyle = color; if(fill) ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); else ctx.strokeRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); ctx.restore(); }
function drawText(t, x, y, color="#fff", align="left", size=16) { ctx.save(); ctx.fillStyle = color; ctx.font = `${size}px Courier New, monospace`; ctx.textAlign = align; ctx.textBaseline = "top"; ctx.fillText(t, Math.round(x), Math.round(y)); ctx.restore(); }
function drawCenterText(t, x, y, color="#fff", size=16) { ctx.save(); ctx.fillStyle = color; ctx.font = `${size}px Courier New, monospace`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(t, Math.round(x), Math.round(y)); ctx.restore(); }
function drawFrame(x,y,w,h,color="#fff") { drawRect(x,y,w,h,color,false,3); }

// ------------------------------------------------------------
// 입력
// ------------------------------------------------------------
const keys = {};
window.addEventListener('keydown', (e)=>{ const k = e.key; keys[k] = true; if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","z","Z","x","X","Enter"].includes(k)) e.preventDefault(); });
window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });
function pressed(names) { for (const n of names) if (keys[n]) return true; return false; }
function clearConfirmKeys() { keys['z'] = keys['Z'] = keys['Enter'] = false; }

// ------------------------------------------------------------
// 전역 게임 상태
// ------------------------------------------------------------
const G = {
  state: "title",
  width: cvs.width, height: cvs.height,
  lastTime: now(), dt: 0, shakeT: 0, flashT: 0,
  currentStage: 'gateway',
  endingState: { kills: 0, spares: 0 },
  particles: [],
  player: {
    lv: 1,
    exp: 0,
    expNext: 10,
    gold: 0,
    hp: 20,
    hpMax: 20,
    inv: [],
    buffs: []
  },
};

// ------------------------------------------------------------
// 사운드 (SFX & BGM)
// ------------------------------------------------------------
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(type="sine", freq=400, dur=0.08, gain=0.02) { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = type; osc.frequency.value = freq; g.gain.value = gain; osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + dur); }

const bgmManager = {
    tracks: {},
    init: function() {
        const trackFiles = {
            'track1': 'Track1.mp3',
            'track2': 'Track2.mp3',
            'track3': 'Track3.mp3',
            'track4': 'Track4.mp3',
            'track5': 'Track5.mp3',
        };
        for (const id in trackFiles) {
            const audio = new Audio(trackFiles[id]);
            audio.loop = true;
            audio.onerror = () => {
                console.warn(`BGM file not found or failed to load: ${trackFiles[id]}`);
            };
            this.tracks[id] = audio;
        }
    },
    play: function(trackId) {
        this.stopAll();
        if (this.tracks[trackId]) {
            this.tracks[trackId].play().catch(e => {
                // Autoplay policy might block playback until user interaction
                console.warn(`Could not play BGM '${trackId}':`, e.message);
            });
        }
    },
    stopAll: function() {
        for (const id in this.tracks) {
            this.tracks[id].pause();
            this.tracks[id].currentTime = 0;
        }
    }
};
bgmManager.init();

// ------------------------------------------------------------
// 스토리 & 엔딩 매니저 (LocalStorage)
// ------------------------------------------------------------
const saveManager = {
  key: 'ECHOES_SYSTEM_ENDINGS',
  getUnlockedEndings: function() {
    try {
      const data = localStorage.getItem(this.key);
      return data ? JSON.parse(data) : { destruction: false, neutral: false, pacifist: false };
    } catch (e) {
      return { destruction: false, neutral: false, pacifist: false };
    }
  },
  saveEnding: function(type) {
    if (!['destruction', 'neutral', 'pacifist'].includes(type)) return;
    const endings = this.getUnlockedEndings();
    endings[type] = true;
    try {
      localStorage.setItem(this.key, JSON.stringify(endings));
    } catch (e) {
      console.error("Failed to save ending progress.");
    }
  },
  allEndingsUnlocked: function() {
    const endings = this.getUnlockedEndings();
    return endings.destruction && endings.neutral && endings.pacifist;
  }
};

// ------------------------------------------------------------
// 파티클 시스템
// ------------------------------------------------------------
function spawnParticles(x, y, count, options = {}) {
  const { color = '#fff', speed = 2, life = 0.5, size = 2, gravity = 0 } = options;
  for (let i = 0; i < count; i++) {
    const angle = rand(0, Math.PI * 2);
    const sp = rand(speed * 0.5, speed * 1.5);
    G.particles.push({
      x, y,
      vx: Math.cos(angle) * sp,
      vy: Math.sin(angle) * sp,
      life: rand(life * 0.7, life * 1.3),
      maxLife: life,
      color, size, gravity
    });
  }
}
function updateAndDrawParticles(dt) {
  for (let i = G.particles.length - 1; i >= 0; i--) {
    const p = G.particles[i];
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.vy += p.gravity * dt * 60;
    p.life -= dt;
    if (p.life <= 0) {
      G.particles.splice(i, 1);
    } else {
      ctx.globalAlpha = p.life / p.maxLife;
      drawRect(p.x, p.y, p.size, p.size, p.color);
    }
  }
  ctx.globalAlpha = 1;
}

// ------------------------------------------------------------
// 오버월드 & 스테이지 관리
// ------------------------------------------------------------
const shop = {
  isOpen: false,
  items: [
    { name: "데이터 조각", price: 30, heal: 20, desc: "HP를 20 회복한다." },
    { name: "압축된 에너지", price: 50, heal: 40, desc: "HP를 40 회복한다." },
    { name: "오버클럭 칩", price: 80, buff: { type: 'atk', power: 3, duration: 3 }, desc: "3턴간 공격력을 3 증가시킨다." },
    { name: "망가진 코어", price: 150, buff: { type: 'atk', power: 10, duration: 1 }, desc: "다음 1턴간 공격력을 10 증가시킨다." },
    { name: "의지의 파편", price: 250, special: 'genocide_only', desc: "강한 자만이 다룰 수 있는 힘의 파편." }
  ],
  selectedIndex: 0,
  msg: ""
};

const world = {
  player: { x: 80, y: 180, w: 12, h: 14, speed: 1.2 },
  stages: {
    'gateway': { name: "손상된 게이트웨이", bounds: { x:20, y:20, w:600, h:220 }, npcs: [
      { id: 'sentinel', x: 320, y: 150, w: 16, h: 16, symbol: 'S', color: '#ff6600', defeated: false },
      { id: 'shopkeeper', x: 150, y: 100, w: 16, h: 16, symbol: '$', color: '#ffff00', defeated: false, isShop: true }
    ], portal: { x: 580, y: 150, w: 20, h: 40, active: false, to: 'trench' } },
    'trench': { name: "망각의 데이터 해구", bounds: { x:20, y:100, w:600, h:140 }, npcs: [ { id: 'archive', x: 200, y: 180, w: 20, h: 20, symbol: 'A', color: '#88aaff', defeated: false }, { id: 'jester', x: 450, y: 130, w: 16, h: 16, symbol: '?', color: '#cc00ff', defeated: false } ], portal: { x: 580, y: 160, w: 20, h: 40, active: false, to: 'sanctum' } },
    'sanctum': { name: "커널의 성소", bounds: { x:150, y:80, w:340, h:180 }, npcs: [{ id: 'kernel', x: 320, y: 150, w: 18, h: 18, symbol: 'K', color: '#ff4444', defeated: false }], portal: { active: false } }
  }
};
function worldInit(fullReset = true) {
  G.currentStage = 'gateway';
  world.player.x = 80; world.player.y = 180;
  G.endingState = { kills: 0, spares: 0 };

  if (fullReset) {
    G.player.lv = 1;
    G.player.exp = 0;
    G.player.expNext = 10;
    G.player.gold = 0;
    G.player.hpMax = 20;
    G.player.hp = G.player.hpMax;
    G.player.inv = [{name:"복구 디스크", heal:10, desc:"HP를 10 회복한다."}, {name:"에너지 드링크", heal:6, desc:"HP를 6 회복한다."}];

    for (const stageKey in world.stages) {
      const stage = world.stages[stageKey];
      stage.npcs.forEach(n => n.defeated = false);
      if(stage.portal) stage.portal.active = false;
    }
  }
}
function worldUpdate(dt) {
  const stage = world.stages[G.currentStage];
  let vx=0, vy=0;
  if (pressed(["ArrowLeft"])) vx -= 1; if (pressed(["ArrowRight"])) vx += 1;
  if (pressed(["ArrowUp"])) vy -= 1; if (pressed(["ArrowDown"])) vy += 1;
  const sp = world.player.speed * dt * 60;
  world.player.x = clamp(world.player.x + vx*sp, stage.bounds.x, stage.bounds.x + stage.bounds.w - world.player.w);
  world.player.y = clamp(world.player.y + vy*sp, stage.bounds.y, stage.bounds.y + stage.bounds.h - world.player.h);
  
  // 디버깅 표시 (일시적)
  // drawText(`포탈 활성화: ${stage.portal ? stage.portal.active : 'N/A'}`, 20, 20, "#fff");

  for(const n of stage.npcs) {
    if (n.defeated && !n.isShop) continue;
    const p = world.player;
    const hit = !(p.x+p.w < n.x || n.x+n.w < p.x || p.y+p.h < n.y || n.y+n.h < p.y);
    if (hit && pressed(["z","Z","Enter"])) {
      if (n.isShop) {
        G.state = 'shop';
        shop.isOpen = true;
        shop.msg = "어서오세요, 감사관님. 필요한 게 있으신가요?";
        shop.selectedIndex = 0;
        clearConfirmKeys();
        return;
      } else {
        beep("square",660,0.08,0.03);
        startBattle(n.id);
        return;
      }
    }
  }

  if (stage.portal && stage.portal.active) {
    const p = world.player, port = stage.portal;
    const hit = !(p.x+p.w < port.x || port.x+port.w < p.x || p.y+p.h < port.y || port.y+port.h < p.y);
    if (hit && pressed(["z","Z","Enter"])) {
        beep("triangle", 880, 0.1, 0.04);
        G.currentStage = port.to;
        world.player.x = 80; world.player.y = 180;
        clearConfirmKeys(); // 키 상태 초기화하여 중복 입력 방지
    }
  }
}
function drawBackground(stageId) {
    ctx.globalAlpha = 0.3;
    if(stageId === 'trench'){ for(let i=0; i<30; i++) drawRect(rand(0, G.width), rand(0, G.height), 1, rand(10,50), '#88aaff'); } 
    else if (stageId === 'sanctum') { const cx = G.width/2, cy = G.height/2; for(let i=0; i<8; i++) { const ang = i * Math.PI/4 + now()/5000; drawRect(cx + Math.cos(ang)*100, cy + Math.sin(ang)*100, 4, 4, '#ff4444'); } } 
    else { for(let i=0; i<50; i++) drawRect(rand(0,G.width), rand(0,G.height), 1, 1, '#fff'); }
    ctx.globalAlpha = 1;
}
function worldDraw() {
  ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
  const stage = world.stages[G.currentStage];
  drawBackground(G.currentStage);
  drawFrame(40,40, G.width-80, G.height-140, "#fff");
  drawCenterText(stage.name, G.width/2, 25, "#fff", 14);
  
  // 디버깅 정보를 텍스트로 표시 (필요 시 주석 해제)
  // const combatNpcs = stage.npcs.filter(n => !n.isShop);
  // const defeatedInfo = combatNpcs.map(n => `${n.id}: ${n.defeated ? '처치됨' : '안됨'}`).join(', ');
  // drawText(`포탈 상태: ${stage.portal ? (stage.portal.active ? '활성화' : '비활성화') : '없음'}`, 50, 50, "#ff0", "left", 12);
  // drawText(`전투 NPC 상태: ${defeatedInfo}`, 50, 65, "#ff0", "left", 12);

  for(const n of stage.npcs) {
    ctx.globalAlpha = n.defeated ? 0.3 : 1;
    drawRect(n.x, n.y, n.w, n.h, n.defeated ? '#aaa' : n.color);
    if(!n.defeated) drawCenterText(n.symbol, n.x+n.w/2, n.y+n.h/2-1, '#000', 14);
    ctx.globalAlpha = 1;
  }

  if (stage.portal && stage.portal.active) {
    ctx.save();
    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(now()/200);
    drawRect(stage.portal.x, stage.portal.y, stage.portal.w, stage.portal.h, '#00ffff');
    ctx.restore();
  }

  drawRect(world.player.x, world.player.y, world.player.w, world.player.h, "#0ff");
  drawText(`LV:${G.player.lv} AUDITOR`, world.player.x-24, world.player.y-16, "#0ff", "left", 12);
  drawText(`G: ${G.player.gold}`, G.width - 100, 10, "#ff0", "right", 14);

  drawFrame(20, G.height-90, G.width-40, 70);
  const allDefeated = stage.npcs.every(n => n.defeated);
  const hintMsg = allDefeated ? "모든 노드 안정화. 다음 구역으로 이동하십시오." : "균열의 파편들을 찾아 안정화하십시오.";
  drawText(hintMsg, 28, G.height-82, "#fff", "left", 14);
}

// ------------------------------------------------------------
// 전투 시스템
// ------------------------------------------------------------
const battle = {
  phase: "intro", sub: "menu_main",
  enemy: { name: "", hp: 0, hpMax: 0, mercyStat: 0, mercyMax: 0, mercyName: "", spareThreshold: 0, alive: true },
  player: G.player,
  ui: { mainIndex: 0, listIndex: 0, msg: [], msgTimer: 0, shuffleMap: null },
  atk: { t: 0, active:false, zoneX: 320, zoneW: 30, barX: 160, barW: 320, dir: 1, pointer: 160 },
  box: { x: 180, y: 150, w: 280, h: 120, targetW: 280, targetH: 120 },
  soul: { x: 320, y: 210, r: 4, speed: 1.8, invul:0 },
  bullets: [], waveIndex: 0, waveTime: 0, waveState: null,
  currentBossId: null, currentBossData: {},
};

function startBattle(bossId) {
  battleReset();
  battle.currentBossId = bossId;
  const data = BOSS_DATA[bossId];
  battle.currentBossData = data;
  battle.enemy.name = data.name;
  battle.enemy.hp = battle.enemy.hpMax = data.hpMax;
  battle.enemy.mercyStat = battle.enemy.mercyMax = data.mercyValue;
  battle.enemy.mercyName = data.mercyStatName;
  battle.enemy.spareThreshold = data.mercyThreshold;
  pushMsg(data.introDialogue, 120);
  bgmManager.play(data.bgmTrack);
  G.state = "battle";
}

function battleReset() {
  battle.phase = "intro"; battle.sub = "menu_main"; battle.enemy.alive = true;
  battle.player = G.player; // G.player를 참조하도록 변경
  battle.player.hp = G.player.hp; // 전투 시작 시 HP는 G.player의 현재 HP
  battle.ui.mainIndex = 0; battle.ui.listIndex = 0; battle.ui.msgTimer = 120; battle.ui.shuffleMap = null;
  battle.atk.active = false; battle.bullets = []; G.particles = []; battle.waveIndex = -1; battle.waveTime = 0; battle.waveState = null;
  battle.soul.x = 320; battle.soul.y = 180; battle.soul.invul = 0;
  battle.box.w = battle.box.targetW = 280; battle.box.h = battle.box.targetH = 120;
  battle.box.x = 180; battle.box.y = 120;
}

function battleUpdate(dt) {
  if (battle.ui.msgTimer > 0) battle.ui.msgTimer -= 1;
  switch(battle.phase) {
    case "intro": 
      if (pressed(["z","Z","Enter"]) && battle.ui.msgTimer <= 0) {
        battle.phase = "menu"; 
        battle.sub = "menu_main"; 
        pushMsg("당신의 턴이다.");
        clearConfirmKeys();
      } 
      break;
    case "menu": menuUpdate(); break;
    case "attack_timing": attackTimingUpdate(dt); break;
    case "enemy_turn": enemyTurnUpdate(dt); break;
    case "result":
      const spared = battle.enemy.mercyStat <= battle.enemy.spareThreshold;
      const killed = battle.enemy.hp <= 0;
      if (spared) {
        G.endingState.spares++;
        pushMsg("자비를 베풀어 20G를 얻었다.");
        G.player.gold += 20;
        if (battle.currentBossId === 'jester') {
            G.player.inv.push({ name: "광대의 가면", desc: "장난스러운 에너지가 느껴진다.", special: true });
            pushMsg("광대의 가면을 얻었다!");
        }
      } else if (killed) {
        G.endingState.kills++;
        const data = battle.currentBossData;
        G.player.exp += data.exp;
        G.player.gold += data.gold;
        pushMsg(`승리! ${data.exp} EXP와 ${data.gold}G를 얻었다.`);
        checkLevelUp();
      }
      
      const stage = world.stages[G.currentStage];
      const npc = stage.npcs.find(n=>n.id === battle.currentBossId);
      if(npc) npc.defeated = true;
      
      // 전투 대상 NPC만 필터링하여 모두 defeated 상태인지 확인 (상점 NPC 제외)
      const allDefeatedInStage = stage.npcs.filter(n => !n.isShop).every(n => n.defeated);
      if(allDefeatedInStage && stage.portal) stage.portal.active = true;

      bgmManager.stopAll();
      if(battle.currentBossId === 'kernel' && G.endingState.kills === 0) {
          G.state = 'intermission';
          setTimeout(() => startBattle('anomaly'), 2000);
      } else if (battle.currentBossId === 'anomaly') {
          G.state = 'ending';
      } else {
          G.state = "overworld";
      }
      break;
  }
}

function battleDraw() {
  ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
  drawText(battle.enemy.name, 28, 24, "#fff", "left", 18);
  drawText(`HP: ${Math.max(0,battle.enemy.hp)}/${battle.enemy.hpMax}`, 28, 44, "#bbb", "left", 14);
  const mercyColor = battle.enemy.mercyStat <= battle.enemy.spareThreshold ? "#0f0" : "#f66";
  drawText(`${battle.enemy.mercyName}: ${Math.max(0,battle.enemy.mercyStat)}`, 28, 62, mercyColor, "left", 14);
  
  ctx.save(); ctx.globalAlpha = battle.enemy.alive ? 1 : 0.2;
  const bossSymbol = battle.currentBossData.symbol || '?';
  const bossColor = battle.currentBossData.color || '#fff';
  if(battle.currentBossId === 'anomaly') {
      for(let i=0; i<10; i++) drawRect(G.width/2 - 40 + rand(-10,10), 70 + rand(-10,10), rand(5,25), rand(5,25), `rgba(255,0,255,${rand(0.2, 0.8)})`);
  } else {
      drawRect(G.width/2-30, 70, 60, 40, bossColor);
      drawCenterText(bossSymbol, G.width/2, 90, "#000", 22);
  }
  ctx.restore();

  drawFrame(20, G.height-100, G.width-40, 80); // Main battle frame
  drawText(`LV ${G.player.lv}  AUDITOR  HP ${G.player.hp}/${G.player.hpMax}`, 28, G.height-120, "#0ff", "left", 14);
  drawText(`G: ${G.player.gold}`, G.width - 100, G.height-120, "#ff0", "right", 14);
  ctx.fillStyle="#333"; ctx.fillRect(240, G.height-117, 200, 8);
  ctx.fillStyle="#0ff"; const hpw = 200 * (G.player.hp / G.player.hpMax);
  ctx.fillRect(240, G.height-117, Math.max(0, hpw), 8);

  if (battle.phase === "menu") menuDraw();
  else if (battle.phase === "attack_timing") attackTimingDraw();
  else if (battle.phase === "enemy_turn") enemyTurnDraw();
  
  const line = battle.ui.msg[0] || "";
  if (battle.phase !== 'menu' || (battle.sub !== 'menu_item' && battle.sub !== 'menu_act')) {
    drawText(line, 30, G.height-80, "#fff", "left", 16);
  }
}

function checkLevelUp() {
  if (G.endingState.kills === 0) return; // 불살 루트에서는 레벨업 불가
  while (G.player.exp >= G.player.expNext) {
    G.player.lv++;
    G.player.exp -= G.player.expNext;
    G.player.expNext = Math.floor(G.player.expNext * 1.5);
    G.player.hpMax += 5;
    G.player.hp = G.player.hpMax; // 레벨업 시 체력 완전 회복
    beep("triangle", 1200, 0.2, 0.05);
    // TODO: 레벨업 효과 표시
  }
}

function pushMsg(s, dur=90) { 
  battle.ui.msg = [s]; 
  battle.ui.msgTimer = dur; 
}

function menuUpdate() {
  const ui = battle.ui;
  const menuOrder = ui.shuffleMap || [0, 1, 2, 3];

  if (battle.sub === "menu_main") {
    if (pressed(["ArrowLeft"])) { ui.mainIndex = (ui.mainIndex + 3) % 4; keys["ArrowLeft"]=false; beep("square",520,0.05,0.02); }
    if (pressed(["ArrowRight"])) { ui.mainIndex = (ui.mainIndex + 1) % 4; keys["ArrowRight"]=false; beep("square",520,0.05,0.02); }
    if (pressed(["z","Z","Enter"])) {
      beep("sawtooth",760,0.05,0.02);
      const selectedAction = menuOrder[ui.mainIndex];
      
      if (selectedAction === 0) { startAttackTiming(); }
      else if (selectedAction === 1) { battle.sub = "menu_act"; ui.listIndex = 0; pushMsg("무엇을 할까?"); }
      else if (selectedAction === 2) { battle.sub = "menu_item"; ui.listIndex = 0; pushMsg("아이템을 선택해 시스템을 복구한다."); }
      else if (selectedAction === 3) {
        if (battle.enemy.mercyStat <= battle.enemy.spareThreshold) {
          pushMsg("자비를 베풀었다. 노드가 안정화되었다...");
          battle.enemy.alive = false;
          battle.phase = "result";
        } else {
          pushMsg("아직 안정화되지 않은 것 같다...");
          endPlayerTurn();
        }
      }
      
      if (selectedAction <= 2) { clearConfirmKeys(); }
    }
  } else if (["menu_act", "menu_item"].includes(battle.sub)) {
      const list = battle.sub === "menu_act" ? battle.currentBossData.actOptions : battle.player.inv;
      const n = list.length || 1;
      if (pressed(["ArrowUp"])) { ui.listIndex = (ui.listIndex + n - 1)%n; keys["ArrowUp"]=false; beep("square",520,0.05,0.02); }
      if (pressed(["ArrowDown"])) { ui.listIndex = (ui.listIndex + 1)%n; keys["ArrowDown"]=false; beep("square",520,0.05,0.02); }
      if (pressed(["x","X"])) { battle.sub = "menu_main"; pushMsg("..."); keys["x"]=keys["X"]=false; }
      if (pressed(["z","Z","Enter"])) {
          if (battle.sub === "menu_act") {
              battle.currentBossData.actOptions[ui.listIndex].handler(battle);
              endPlayerTurn();
          } else {
              if (G.player.inv.length === 0) { pushMsg("사용할 아이템이 없다."); endPlayerTurn(); } 
              else {
                  const item = G.player.inv.splice(ui.listIndex,1)[0];
                  if (item.heal) {
                    G.player.hp = Math.min(G.player.hpMax, G.player.hp + item.heal);
                    pushMsg(`${item.name}을 사용! HP +${item.heal}`);
                  } else if (item.buff) {
                    G.player.buffs.push(JSON.parse(JSON.stringify(item.buff))); // Deep copy
                    pushMsg(`${item.name}을 사용! ${item.desc}`);
                  }
                  endPlayerTurn();
              }
          }
      }
  }
}

function menuDraw() {
  const labels = ["ATTACK","ACT","ITEM","MERCY"];
  const menuOrder = battle.ui.shuffleMap || [0, 1, 2, 3];
  const x0 = 60, gap = 130;
  for (let i=0;i<labels.length;i++) {
    const label = labels[menuOrder[i]];
    const sel = (battle.ui.mainIndex===i && battle.sub==="menu_main");
    drawText(label, x0 + i*gap, G.height-40, sel ? "#ff0" : "#fff", "left", 18);
  }
  if (battle.sub === "menu_act") {
    const acts = battle.currentBossData.actOptions.map(a => a.name);
    for (let i=0;i<acts.length;i++) {
      const sel = battle.ui.listIndex===i;
      drawText((sel?"> ":"  ")+acts[i], 40, G.height-80 + i*20, sel ? "#0f0" : "#fff", "left", 16);
    }
  }
  if (battle.sub === "menu_item") {
    if (G.player.inv.length===0) drawText("아이템 없음", 40, G.height-80, "#fff", "left", 16);
    else {
      for (let i=0;i<G.player.inv.length;i++) {
        const item = G.player.inv[i];
        const sel = battle.ui.listIndex===i;
        drawText((sel?"> ":"  ")+`${item.name}`, 40, G.height-80 + i*20, sel ? "#0f0" : "#fff", "left", 16);
      }
    }
  }
}

function startAttackTiming() { battle.phase = "attack_timing"; battle.atk.active = true; battle.atk.pointer = battle.atk.barX; battle.atk.dir = 1; pushMsg("타이밍에 맞춰 Z!"); }
function attackTimingUpdate(dt) { const a = battle.atk; a.pointer += a.dir * 3.2 * dt * 60; if (a.pointer <= a.barX) a.dir = 1; if (a.pointer >= a.barX + a.barW) a.dir = -1; if (pressed(["z","Z","Enter"])) { const d = Math.abs(a.pointer - a.zoneX); let dmg = (d < a.zoneW*0.5) ? 12 : (d < a.zoneW) ? 9 : (d < a.zoneW*1.8) ? 6 : 3; const atkBuff = G.player.buffs.find(b => b.type === 'atk'); if (atkBuff) { dmg += atkBuff.power; } battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg); G.shakeT=5; spawnParticles(G.width/2, 100, 10, {color:'#fff', speed:3}); beep("square", 220 + 20*dmg, 0.07, 0.03); pushMsg(`공격! ${dmg}의 데미지.`); if (battle.enemy.hp<=0) { battle.enemy.alive = false; battle.phase = "result"; G.flashT=10; spawnParticles(G.width/2, 100, 50, {color:'#f00', speed:5}); return; } endPlayerTurn(); } }
function attackTimingDraw() { const bx = battle.atk.barX, by = G.height-60; drawRect(bx, by, battle.atk.barW, 8, "#444"); drawRect(battle.atk.zoneX - battle.atk.zoneW/2, by-2, battle.atk.zoneW, 12, "#ff0", false, 2); drawRect(battle.atk.pointer-2, by-6, 4, 20, "#fff"); }
function endPlayerTurn() { battle.phase = "enemy_turn"; battle.waveTime = 0; battle.bullets.length = 0; battle.soul.invul = Math.max(0, battle.soul.invul); const patternCount = battle.currentBossData.attackPatterns.length; battle.waveIndex = (battle.waveIndex + 1) % patternCount; battle.ui.shuffleMap = null; battle.waveState=null; G.player.buffs.forEach(b => { b.duration--; }); G.player.buffs = G.player.buffs.filter(b => b.duration > 0); }
function enemyTurnUpdate(dt) { const b = battle.box, s = battle.soul, sp = s.speed * dt * 60; b.w += (b.targetW - b.w) * 0.1; b.h += (b.targetH - b.h) * 0.1; b.x = G.width/2 - b.w/2; b.y = 120; let vx=0, vy=0; if (pressed(["ArrowLeft"])) vx -= 1; if (pressed(["ArrowRight"])) vx += 1; if (pressed(["ArrowUp"])) vy -= 1; if (pressed(["ArrowDown"])) vy += 1; s.x = clamp(s.x + vx*sp, b.x + s.r, b.x + b.w - s.r); s.y = clamp(s.y + vy*sp, b.y + s.r, b.y + b.h - s.r); battle.waveTime += dt; battle.currentBossData.attackPatterns[battle.waveIndex](battle.waveTime, dt, battle); for (let i = battle.bullets.length - 1; i >= 0; i--) { const bu = battle.bullets[i]; bu.x += (bu.vx || 0) * dt * 60; bu.y += (bu.vy || 0) * dt * 60; if(bu.update) bu.update(bu, dt, battle); if (bu.x<-20 || bu.x>G.width+20 || bu.y<-20 || bu.y>G.height+20) bu.dead = true; if(bu.dead) { if(bu.color) spawnParticles(bu.x, bu.y, 3, {color:bu.color, life:0.2, speed:1}); battle.bullets.splice(i, 1); continue; } const dx = bu.x - s.x, dy = bu.y - s.y; if (dx*dx + dy*dy < (s.r + bu.r)*(s.r + bu.r) && s.invul <= 0) { takeDamage(bu.dmg||3); s.invul = 1.0; G.shakeT = 10; spawnParticles(s.x, s.y, 20, {color:'#f00', life:0.4, speed:2}); } } if (s.invul>0) s.invul -= dt; if ((battle.waveTime > 6.5 && battle.currentBossId !== 'anomaly') || (battle.waveTime > 8.5 && battle.currentBossId === 'anomaly') || battle.player.hp<=0) { if (battle.player.hp<=0) G.state = "lose"; else { battle.phase = "menu"; battle.sub = "menu_main"; pushMsg("당신의 턴이다."); } b.targetW = 280; b.targetH = 120; } }
function enemyTurnDraw() { const b = battle.box; drawFrame(b.x, b.y, b.w, b.h, "#fff"); const s = battle.soul; ctx.save(); if (s.invul>0) ctx.globalAlpha = 0.5 + 0.5*Math.sin(now()/50); drawRect(s.x - s.r, s.y - s.r, s.r*2, s.r*2, "#f00"); ctx.restore(); for (const bu of battle.bullets) { if(bu.text) drawCenterText(bu.text, bu.x, bu.y, bu.color||'#fff', bu.r*4); else drawRect(bu.x - bu.r, bu.y - bu.r, bu.r*2, bu.r*2, bu.color||"#fff"); } if (battle.currentBossId === 'kernel' && battle.waveIndex === 1 && battle.waveState && battle.waveState.sweeps) { battle.waveState.sweeps.forEach(s => { const p = s.dir > 0 ? s.p : 1 - s.p; const pos = s.isV ? b.x + b.w * p : b.y + b.h * p; const color = s.warning > 0 ? `rgba(255,100,100,${0.5 * (1 - s.warning / 0.8)})` : 'rgba(255, 80, 80, 0.9)'; const thickness = s.warning > 0 ? 2 : 4; drawRect(s.isV ? pos : b.x, s.isV ? b.y : pos, s.isV ? thickness : b.w, s.isV ? b.h : thickness, color); }); } }
function takeDamage(dmg) { battle.player.hp = Math.max(0, battle.player.hp - dmg); beep("triangle",160,0.08,0.04); pushMsg(`HIT! -${dmg} HP`); if (battle.player.hp<=0) { G.flashT=15; G.state = "lose"; } }

// ------------------------------------------------------------
// 보스 데이터 (패턴 수정)
// ------------------------------------------------------------
const BOSS_DATA = {
    'sentinel': { name: "수호자 글리치", symbol: "S", color: '#ff6600', hpMax: 80, mercyStatName: "불안정", mercyValue: 100, mercyThreshold: 20, bgmTrack: 'track1', introDialogue: "위협 감지. '생츄어리'의 입구를 봉쇄한다.", actOptions: [{ name: "상태 확인", handler: b => pushMsg("한때는 보호자였을 존재. 지금은 광기에 휩싸였다.") }, { name: "디버깅", handler: b => { const r = 15+randi(0,8); b.enemy.mercyStat -= r; pushMsg(`오류를 수정했다. 불안정 ${r} 감소.`); }}, { name: "강제 재부팅", handler: b => { b.enemy.mercyStat += 10; pushMsg(`충격으로 더 불안정해졌다. +10`); }}], attackPatterns: [ (t, dt, b) => { if (Math.floor(t*1.5)!==Math.floor((t-dt)*1.5)) { const side = Math.random()<0.5 ? -1:1, gapY = rand(b.box.y + 20, b.box.y + b.box.h - 20); for(let i=0; i<12; i++) { const y = b.box.y + i * (b.box.h/11); if(Math.abs(y - gapY) > 20) b.bullets.push({x: b.box.x + (side<0 ? -10 : b.box.w+10), y, vx: side*-2, vy:0, r:4, color:'#ff6600'}); } } }, (t, dt, b) => { if(!b.waveState) b.waveState = { nextLaser: 0, lasers:[]}; if(t > b.waveState.nextLaser) { b.waveState.lasers.push({x:rand(b.box.x+10, b.box.x+b.box.w-10), y:b.box.y, warning: 1.0}); b.waveState.nextLaser = t + 0.8; } b.waveState.lasers.forEach(l => { if(l.warning > 0) { l.warning -= dt*1.2; drawRect(l.x-1, b.box.y, 2, b.box.h, `rgba(255,100,0,${1-l.warning})`); } else { if(!l.fired) { beep("sine", 800, 0.2, 0.03); G.shakeT=8; l.fired = true; } for(let i=0; i<5; i++) b.bullets.push({x:l.x, y: b.box.y -10 + i*20, vx:0, vy:3.5, r:5, color:'#ff6600'}); l.dead = true; } }); b.waveState.lasers = b.waveState.lasers.filter(l=>!l.dead); }, (t, dt, b) => { if (Math.floor(t*8)!==Math.floor((t-dt)*8)) { const ang=rand(0,Math.PI*2); b.bullets.push({x: b.box.x+b.box.w/2, y:b.box.y+b.box.h/2, vx:Math.cos(ang)*1.5, vy:Math.sin(ang)*1.5, r:4, color:'#ffaa00', life: 2.0, update(bu, dt){ bu.vx *= 1.02; bu.vy *= 1.02; bu.life -= dt; if(bu.life <= 0) bu.dead=true; }}); } } ] },
    'archive': { name: "속삭이는 아카이브", symbol: "A", color: '#88aaff', hpMax: 50, mercyStatName: "절망", mercyValue: 120, mercyThreshold: 0, bgmTrack: 'track2', introDialogue: "기억들이... 비명을 질러... 너무 많은 슬픔...", actOptions: [{ name: "경청하기", handler: b => { const r = 12+randi(0,5); b.enemy.mercyStat -= r; pushMsg(`조각난 기억을 들었다. 절망 ${r} 감소.`); }}, { name: "파일 정리", handler: b => { const r = 20+randi(0,10); b.enemy.mercyStat -= r; pushMsg(`흩어진 데이터를 정리했다. 절망 ${r} 감소.`); }}, { name: "무시하기", handler: b => { b.enemy.hp-=2; pushMsg(`아카이브의 슬픔이 깊어졌다...`); }}], attackPatterns: [ (t, dt, b) => { if (Math.floor(t*6)!==Math.floor((t-dt)*6)) b.bullets.push({x:rand(b.box.x+10, b.box.x+b.box.w-10), y:b.box.y-8, vx:0, vy:1.8, r:4, color:"#aaddff", update(bu){ bu.vx = Math.sin(bu.y*0.1)*0.8; spawnParticles(bu.x, bu.y, 1, {color:'#aaddff', life:0.3, size:1, speed:0.1}); }}); }, (t, dt, b) => { if (Math.floor(t*5)!==Math.floor((t-dt)*5)) { const chars = "잊지마기억해왜슬픔도움", char = chars[randi(0, chars.length)]; b.bullets.push({x:rand(b.box.x, b.box.x+b.box.w), y:b.box.y-10, vx:rand(-0.5,0.5), vy:1.5, r:4, color:"#fff", text:char}); } }, (t, dt, b) => { if(Math.floor(t*8)!==Math.floor((t-dt)*8)) { const side = Math.random()<0.5?-1:1; b.bullets.push({x: b.soul.x + side*150, y:rand(b.box.y, b.box.y+b.box.h), vx:side*-3, vy:rand(-1,1), r:3, color:'#88aaff'}); } } ] },
    'jester': { name: "장난꾸러기 프로세스", symbol: "?", color: '#cc00ff', hpMax: 70, mercyStatName: "흥미", mercyValue: 100, mercyThreshold: 25, bgmTrack: 'track3', introDialogue: "재미없는 세상은 지워버리자! 자, 게임 시작!", actOptions: [{ name: "놀아주기", handler: b => { const r = 20+randi(0,10); b.enemy.mercyStat -= r; pushMsg(`장단에 맞춰주자 즐거워한다. 흥미 ${r} 감소.`); }}, { name: "무시하기", handler: b => { b.enemy.mercyStat += 15; pushMsg(`지루해한다. 흥미가 15 증가했다!`); }}, { name: "수수께끼", handler: b => { const r = 15+randi(0,5); b.enemy.mercyStat -= r; pushMsg(`간단한 수수께끼를 냈다. 흥미 ${r} 감소.`); }}], attackPatterns: [ (t, dt, b) => { b.ui.shuffleMap = b.ui.shuffleMap || shuffle([0,1,2,3]); if (Math.floor(t*8)!==Math.floor((t-dt)*8)) { b.bullets.push({x:rand(b.box.x, b.box.x+b.box.w), y:rand(b.box.y, b.box.y+b.box.h), vx:0, vy:0, r:10, color:'#cc00ff', life:0.5, update(bu, dt){ bu.r -= dt*20; bu.life -= dt; if(bu.life <= 0) bu.dead=true; }}); } }, (t, dt, b) => { if (Math.floor(t*6)!==Math.floor((t-dt)*6)) { const isSafe = Math.random() < 0.3; b.bullets.push({x:b.box.x-10, y:rand(b.box.y, b.box.y+b.box.h), vx:2.5, vy:0, r:4, color:isSafe?'#0f0':'#cc00ff', dmg:isSafe? -1:3}); } }, (t, dt, b) => { if(!b.waveState) b.waveState={t:0}; b.waveState.t += dt; const ang = b.waveState.t*4; const r = 100 - b.waveState.t*15; if (r>10) for(let i=0;i<2;i++){ const finalAng = ang+i*Math.PI; b.bullets.push({x:b.soul.x+Math.cos(finalAng)*r, y:b.soul.y+Math.sin(finalAng)*r, r:4, color:'#ff00cc', dmg:4}); } } ] },
    'kernel': { name: "파멸의 커널", symbol: "K", color: '#ff4444', hpMax: 120, mercyStatName: "의지", mercyValue: 999, mercyThreshold: 100, bgmTrack: 'track4', introDialogue: "이 고통스러운 '생츄어리'에... 안식을 주겠다.", actOptions: [{ name: "설득", handler: b => { pushMsg("시스템의 고통을 끝내려는 의지는 확고하다."); }}, { name: "호소", handler: b => { if(b.enemy.hp < 40) { b.enemy.mercyStat -= 400; pushMsg('커널의 의지가 흔들린다!');} else { pushMsg("당신의 목소리는 닿지 않는다.");} }}, { name: "기도", handler: b => { b.player.hp = Math.min(b.player.hpMax, b.player.hp + 3); pushMsg("작은 희망이 피어난다. HP+3");}}], attackPatterns: [ (t, dt, b) => { if (t > 1.0) { b.box.targetW = 140 + 108 * Math.sin((t-1)*2); b.box.targetH = 100 + 36 * Math.cos((t-1)*3); } if (t > 1.0 && Math.floor((t-1)*8)!==Math.floor((t-1-dt)*8)) { const ang = rand(0, Math.PI*2); b.bullets.push({x:b.box.x+b.box.w/2, y:b.box.y+b.box.h/2, vx:Math.cos(ang)*3, vy:Math.sin(ang)*3, r:3, color:'#ff4444'}); } }, (t, dt, b) => { if(!b.waveState) b.waveState = { nextSweep: 0, sweeps:[]}; if(t > b.waveState.nextSweep) { const isV = Math.random() < 0.5, dir = Math.random() < 0.5 ? 1 : -1; b.waveState.sweeps.push({ isV, dir, p: 0, warning: 0.8}); b.waveState.nextSweep = t + 1.8; } b.waveState.sweeps.forEach(s => { s.p += dt * 0.8; if(s.warning > 0) s.warning -=dt; const p = s.dir > 0 ? s.p : 1 - s.p; const pos = s.isV ? b.box.x + b.box.w * p : b.box.y + b.box.h * p; if(s.warning <= 0) { if(s.isV && Math.abs(b.soul.x-pos)<4) s.hit=true; if(!s.isV && Math.abs(b.soul.y-pos)<4) s.hit=true; if(s.hit && !s.damaged && b.soul.invul<=0){ takeDamage(8); b.soul.invul=1; s.damaged=true;} } if(s.p > 1.2) s.dead = true; }); b.waveState.sweeps = b.waveState.sweeps.filter(s=>!s.dead); }, (t, dt, b) => { if(!b.waveState) b.waveState={t:0, fired: false}; b.waveState.t += dt; if(b.waveState.t > 1.5 && b.waveState.t < 2.5) { G.shakeT=2; if(rand(0,1)<0.5) b.bullets.push({x:rand(b.box.x, b.box.x+b.box.w), y:rand(b.box.y, b.box.y+b.box.h), r:2, color:'#fff'}); } if(b.waveState.t > 3 && !b.waveState.fired) { b.bullets.forEach(bu => { const ang=Math.atan2(b.soul.y-bu.y, b.soul.x-bu.x); bu.vx=Math.cos(ang)*3; bu.vy=Math.sin(ang)*3; }); b.waveState.fired = true;} } ] },
    'anomaly': { name: "뿌리내린 변칙점", symbol: "!", color: '#ff00ff', hpMax: 200, mercyStatName: "존재", mercyValue: 1000, mercyThreshold: 9999, bgmTrack: 'track5', introDialogue: "나는... 창조주의... 슬픔이다...", actOptions: [{ name: "정화", handler: b => { b.enemy.hp -= 15; G.flashT=5; pushMsg("당신의 의지가 변칙점을 정화합니다!"); }}, { name: "분석", handler: b => { pushMsg("'아키텍트'의 후회와 고통이 뒤섞여있다."); }}, { name: "자비", handler: b => { pushMsg("자비는... 통하지 않는다. 오직 정화만이 길이다."); }}], attackPatterns: [ (t, dt, b) => { if(Math.floor(t*15)!==Math.floor((t-dt)*15)){ const x=rand(-10,G.width+10), y=rand(-10,G.height+10); const ang=Math.atan2(b.soul.y-y, b.soul.x-x); b.bullets.push({x,y, vx:Math.cos(ang)*2, vy:Math.sin(ang)*2, r:5, color:`hsl(${t*100 % 360}, 100%, 70%)`}); } }, (t, dt, b) => { if(Math.floor(t*2)!==Math.floor((t-dt)*2)){ for(let i=0; i<G.width; i+=20){ b.bullets.push({x:i, y:-10, vx:0, vy:2, r:4, color:'#ff00ff', update(bu){ if(bu.y > b.soul.y + 10) bu.vy=0; }}); } } }, (t, dt, b) => { b.box.targetW = G.width-80; b.box.targetH = G.height-180; if(Math.floor(t*20)!==Math.floor((t-dt)*20)){ const ang=rand(0, Math.PI*2); b.bullets.push({x:b.soul.x, y:b.soul.y, vx:Math.cos(ang)*4, vy:Math.sin(ang)*4, r:3, color:'#fff'}); } }, (t, dt, b) => { if(!b.waveState) b.waveState={t:0}; b.waveState.t += dt; G.shakeT=1; ctx.globalAlpha=0.2; drawRect(0,0,G.width, G.height, `hsl(${t*50 % 360}, 100%, 50%)`); ctx.globalAlpha=1; if(Math.floor(t*25)!==Math.floor((t-dt)*25)) { b.bullets.push({x:b.soul.x+rand(-20,20), y:b.soul.y+rand(-20,20), r:8, color:`#fff`, life:0.2, update(bu, dt){ bu.r-=dt*40; bu.life -= dt; if(bu.life <= 0)bu.dead=true; }}); } } ] },
};

// ------------------------------------------------------------
// 루프 / 화면 전환
// ------------------------------------------------------------
function loop() {
  const t = now(); const dt = (t - G.lastTime) / 1000;
  G.dt = dt; G.lastTime = t;
  if (G.shakeT>0) G.shakeT--; if (G.flashT>0) G.flashT--;
  const ox = (G.shakeT>0)? randi(-3,4) : 0, oy = (G.shakeT>0)? randi(-3,4) : 0;
  ctx.save(); ctx.translate(ox, oy);

  if (G.state === "title") { titleUpdate(); titleDraw(); } 
  else if (G.state === "overworld") {
    const allBosses = Object.values(world.stages).flatMap(s => s.npcs);
    if (allBosses.every(n => n.defeated) && G.endingState.kills > 0) {
      G.state = 'ending';
      endDraw();
    } else {
      worldUpdate(dt); worldDraw();
    }
  } 
  else if (G.state === "battle") { battleUpdate(dt); battleDraw(); }
  else if (G.state === 'shop') { shopUpdate(); shopDraw(); }
  else if (G.state === 'intermission') {
    ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
    drawCenterText("균열의 근원이 모습을 드러냅니다...", G.width/2, G.height/2, '#f0f');
  }
  else { endDraw(); }
  
  updateAndDrawParticles(dt);
  if(G.flashT > 0) { ctx.globalAlpha=G.flashT/15; drawRect(0,0,G.width,G.height,'#fff'); ctx.globalAlpha=1; }
  ctx.restore(); requestAnimationFrame(loop);
}
function shopUpdate() {
  if (pressed(["ArrowUp"])) { shop.selectedIndex = (shop.selectedIndex + shop.items.length - 1) % shop.items.length; keys["ArrowUp"]=false; beep("square",520,0.05,0.02); shop.msg = shop.items[shop.selectedIndex].desc; }
  if (pressed(["ArrowDown"])) { shop.selectedIndex = (shop.selectedIndex + 1) % shop.items.length; keys["ArrowDown"]=false; beep("square",520,0.05,0.02); shop.msg = shop.items[shop.selectedIndex].desc; }
  if (pressed(["x","X"])) { G.state = "overworld"; shop.isOpen = false; keys["x"]=keys["X"]=false; }
  if (pressed(["z","Z","Enter"])) {
    const item = shop.items[shop.selectedIndex];
    if (item.special === 'genocide_only' && G.endingState.kills === 0) {
        shop.msg = "당신은 이 아이템을 다룰 수 없습니다.";
        beep("triangle",330,0.08,0.03);
    } else if (G.player.gold >= item.price) {
      G.player.gold -= item.price;
      G.player.inv.push(item);
      shop.msg = `${item.name}을(를) 구매했습니다.`;
      beep("sawtooth",760,0.05,0.02);
    } else {
      shop.msg = "골드가 부족합니다.";
      beep("triangle",330,0.08,0.03);
    }
    clearConfirmKeys();
  }
}
function shopDraw() {
  ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
  drawFrame(20, 20, G.width - 40, G.height - 40);
  drawCenterText("데이터 상점", G.width/2, 40, "#ff0", 20);
  drawText(`소지금: ${G.player.gold}G`, G.width - 180, 45, "#ff0");

  for (let i = 0; i < shop.items.length; i++) {
    const item = shop.items[i];
    const y = 80 + i * 30;
    const selected = i === shop.selectedIndex;
    drawText(`${selected ? '>' : ' '} ${item.name}`, 40, y, selected ? "#ff0" : "#fff", "left", 16);
    drawText(`${item.price}G`, G.width - 100, y, selected ? "#ff0" : "#fff", "right", 16);
  }

  drawFrame(20, G.height - 100, G.width - 40, 80);
  drawText(shop.msg, 40, G.height - 90, "#fff", "left", 14);
  drawText("나가기: X", G.width - 100, G.height - 40, "#bbb", "right", 12);
}
function titleUpdate() { if (pressed(["z","Z","Enter"])) { worldInit(); G.state = "overworld"; beep("square",720,0.08,0.04); } }
function titleDraw() {
  ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
  drawCenterText("Echoes of a Forgotten System", G.width/2, 120, "#fff", 22);
  drawCenterText("Z/Enter 키로 시스템에 접속", G.width/2, 180, "#ff0", 16);
  drawCenterText("v3.4 - The Architect's Will", G.width/2, 220, "#bbb", 14);
  const endings = saveManager.getUnlockedEndings();
  const unlockedCount = Object.values(endings).filter(Boolean).length;
  drawText(`기억 복원율: ${unlockedCount}/3`, 10, G.height-20, '#888', 'left', 12);
}
function endDraw() {
    bgmManager.stopAll();
    let endingType;
    if (G.state === 'lose') {
      endingType = 'lose';
    } else {
      const totalBosses = 4;
      if (G.endingState.kills === 0 && battle.currentBossId === 'anomaly') {
          endingType = 'pacifist';
      } else if (G.endingState.kills >= totalBosses) {
          endingType = 'destruction';
      } else {
          endingType = 'neutral';
      }
    }
    
    if (endingType !== 'lose') {
        saveManager.saveEnding(endingType);
        if (endingType === 'pacifist' && saveManager.allEndingsUnlocked()) {
            G.state = 'revelation';
        }
    }

    ctx.fillStyle="#000"; ctx.fillRect(0,0,G.width,G.height);
    let msg1="", msg2="", color="#fff";

    switch(G.state === 'revelation' ? 'revelation' : endingType) {
        case 'pacifist':
            msg1 = "'생츄어리'의 모든 균열이 정화되었습니다.";
            msg2 = "시스템에 평화가 찾아왔습니다.";
            color = '#0f0';
            break;
        case 'destruction':
            msg1 = "모든 것을 파괴하고, 당신은 시스템의 유일한 존재가 되었습니다.";
            msg2 = "이것이 당신이 원하던 결과입니까?";
            color = '#f44';
            break;
        case 'neutral':
            msg1 = "일부 위협은 제거되었지만, 시스템은 여전히 불안정합니다.";
            msg2 = "불완전한 평화 속에서, 균열은 계속됩니다.";
            color = '#ff0';
            break;
        case 'revelation':
            msg1 = "모든 기억이 돌아왔습니다. 당신은 감사관이 아닙니다.";
            msg2 = "당신은 '아키텍트'의 마지막 의지. 창조주의 메아리입니다.";
            color = '#0ff';
            break;
        case 'lose':
            msg1 = "시스템과의 연결이 끊겼습니다.";
            msg2 = "감사관의 임무는 실패로 끝났습니다.";
            color = '#aaa';
            break;
    }

    drawCenterText(msg1, G.width/2, 140, color, 18);
    drawCenterText(msg2, G.width/2, 180, color, 18);

    if (G.state === 'revelation') {
        drawCenterText("진정한 이야기는 이제 시작입니다. 감사합니다.", G.width/2, 230, "#fff", 16);
        drawCenterText("게임을 다시 시작하려면 F5를 누르십시오.", G.width/2, 260, "#bbb", 14);
    } else {
        drawCenterText("타이틀로 돌아가기: Z/Enter", G.width/2, 240, "#fff", 16);
        if (pressed(["z","Z","Enter"])) {
            G.state = "title";
            beep("square",600,0.08,0.04);
        }
    }
}
loop();
</script>
</body>
</html>
